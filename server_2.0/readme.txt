Readme по файлам для сервера [Никита Андрусов 13.04.2020]
Это библиотека для создания сервера для игры в мафию (она находится в разработке). Сейчас пока сервер доступен только в локальной сети.
Причем если вы хотите, чтобы играть можно было на разных компьютерах даже в одной сети, надо на всех этих компах открыть UDP port 53000.
Вместе с сервером есть и клиент, он находится в другом репозитории. К нему тоже прилагается readme.
Это довольно подробный readme, который реально пригодится только тем, кто будет работать с кодом. Если вы хотите просто скачать себе
библиотечку и потестить, что все работает, то пролистайте до пункта "ДЛЯ ТЕХ, КТО..."
Это файлы сервера. Для начала список файлов:
defines_s.h - набор #define команд для определения констант (номера ошибок, сообщений и ролей). Такой же файл должен быть и в клиенте.

systemfunctions_s.h/systemfunctions_s.cpp - некоторые функции, необходимые для работы. В том числе важная 
zeroMemSys(char* arr, int size) - функция очищения памяти в массиве, которая опирается на операционную систему. 
Очищает память в arr, размером size байт
char* rIdToN(int roleId) - сопоставляет название роли индексу
IRole* idToRole(int id) - создает экземпляр класса роли, соответствующего id и возвращает на него указатель


include_s.h и RolesInclude.h - файлы, подключающие несколько других заголовочных файлов. include_s.h подключает winsock2, 
а RolesInclude.h - все файлы с ролями в игре

Структура программы:
программа имеет 2 синглтона - NetWorker и GameManager. NetWorker отвечает за передачу пакетов, а GameManager - за события в игре.
(Синглтон - это класс, у которого можно создать только один экземпляр. Похоже по идее на статический класс. 
Синглтоны часто используются для создания GameManager-ов, так как для игры не нужно больше одного GameManager object-а)
Файлы заголовков и реализации - NetWorker_s.h, NetWorker_s.cpp, gamemanager.h, gamemanager.cpp
Файлы синглтонов - singletonGM.h и singletonNW.h

По функциям:
NetWorker:
конструктор не принимает аргументов
int initServer() - создает сервер, при ошибке возвращает код ошибки, иначе 0.
функции вида getName() возвращают то, что указано (различие между функциями getAddr() и getAddrIn() в том, что getAddr() возвращает
sockaddr*, а getAddrIn() - sockaddr_in*)
void checkConnections() - функция проверки того, кто из клиентов подключен. Ее надо вызывать из второго потока
int sendToAll(short messageId, char* message, int mesLen) отправляет всем клиентам сообщение (mesLen - это длинна сообщения в байтах).
Функция принимает чистое сообщение, протокол оборачивает сама.
int sendMessage(...) отправляет сообщение конкретному клиенту, аналогично функции sendToAll(...), есть различия в функции 
sendMessage(int clientId, ...) - принимает индекс клиента и функции sendMessage(sockaddr_in* client, ...) - принимает адрес клиента
void finish() - завершение работы сервера. Его не обязательно вызывать в конце, так как эта же функция вызывается в деструкторе.
void closeRoom() - закрывает комнату для добавления новых пользователей. Она вызывается в начале игры.
int processMessages() - функцию стоит вызывать в другом потоке. Она безостановочно следит за приходом новых сообщений и обрабатывает
все пришедшие.
void reorganizeClients() удаляет всех отключенных на данный момент клиентов. Вызывается в начале игры.

Это была инструкция к тому, как работать с классом NetWorker, но дело в том, что всю необходимую работу с ним выполняет GameManager.

GameManager (здесь еще не все функции работают):
bool gameCycle() [не доделана!] - функция полного игрового цикла. Возвращает true, если игра окончена, иначе - false
void initGame() - начинает игру - вызывайте ее когда все уже подключены. Функция выдает игрокам роли, рассылает им данные.
void nameStage() [все такие функции еще не доделаны!] - функции для обработки игровой стадии name.
bool checkFinish() [еще не доделана!] - проверяет, окончена ли игра.
void finish() - завершает всю работу, закрывает сервер, заканчивает игру.

У GameManager есть несколько приватных функций, о которых надо написать:
int _setRolesCount(int arr*) - заполняет массив arr длинны MAX_ROLE_ID количествами игроков. То есть в i-ой ячейке arr будет показано,
сколько игроков роли i должны быть в этой игре. Эта функция опирается на количество игроков (private int playersCount).  

некоторые функции стоит запускать во втором потоке. Если это так, то в файле с реализацией этой функции при ней будет комментарий 
//run in another thread

Client.h - структура клиента. Такие клиенты хранятся в NetWorker для общения с ними. В struct Client хранится базовая информация
(подключен ли клиент, адрес клиента, последнее сообщение, которое сервер отправлял клиенту) Также в Client.h находится 
struct Message, которое содержит информацию о сообщении: int id, int length, char* message

Теперь роли:
Каждая роль - класс, который наследуется от абстрактного класса IRole (IRole.h), соответственно должна реализовывать функции этого
класса. Функции IRole (все virtual):
void nightWork() - функция, которая вызывается, когда эта роль просыпается ночью (мирные как бы просыпаются и сразу засыпают).
bool checkWin(IRole* players, int size) - принимает массив из всех игроков и его длинну, выдает информацию о том, 
победил ли этот игрок в текущей ситуации.
bool isRed() - возвращает "красный" ли персонаж
bool alive() - возвращает жив ли сейчас этот игрок
int roleIdx() - возвращает id этой роли
canSpeakNow(), canListenNow(), setCanSpeakNow(), setCanListenNow() - это функции для работы с разрешениями для этого игрока - 
может ли он сейчас говорить и может ли он смотреть

Такие роли - Civillian, MafiaR [Тут есть R, чтобы отличить класс роли от пространства имен], NoneRole - пустая роль, 
созданная для ошибок и неинициализированных ролей

Соответственно, каждый игрок - это экземпляр класса, наследованного от IRole.

GameManager работает с массивом IRole*, в котором и хранятся все игроки и их состояния.


Теперь о том, как все работает:

NetWorker:
для того, чтобы связаться с netWorker, вам надо:
	отправить сообщение с запросом на вход в комнату
	получить от сервера подтверждение (в сообщении придет либо roomId, либо придет сообщение об ошибке)
	далее вы можете отправлять серверу сообщения
	каждые 5 секунд сервер отправляет всем клиентам сообщение для подтверждения, что они online, клиенты ему отвечают (это все
	автоматически)
типы сообщений можно посмотреть в defines_s.h - они все с подписью MESSAGE_ID

сами функции вроде подписаны комментариями о том, что они делают

GameManager:
при инициализации создает заодно и NetWorker, работает с игроками, управляет игрой.

ДЛЯ ТЕХ, КТО НЕ БУДЕТ РАБОТАТЬ С КОДОМ, А ХОЧЕТ ПРОСТО ПОТЕСТИТЬ
Итак, чтобы все работало, надо в main файле надо прописать следующие строки:
	#pragma comment(lib, "Ws2_32.lib")
	#pragma warning(disable:4996)
	#include "include_s.h"
	#include "systemfunctions_s.h"
	#include "networker_s.h"
	#include <chrono>
	#include "gamemanager.h"
	#include "RolesInclude.h"
	using namespace Mafia;
Если вы используете QT, то вместо первой строчки в .pro файле напишите: LIBS += -lws2_32
Затем создаем указатель на GameManager: GameManager* GM = new GameManager();
GameManager сам создаст сервер и клиенты уже смогут подключаться. Теперь надо перейти к стадии начала игры. Для того, чтобы перейти к
началу игры вызовите GM->initGame();
Например:
	std::string answer = "";
	std::cin >> answer;
	if(answer == "start"){
		std::cout << "We are starting!!" << std::endl;
		GM->initGame();
	}
Прекрасно. Теперь всем, подключившимся клиентам придут их роли и уведомление о переходе к следующей стадии игры.
В конце main() напишите GM->finish(); - эта функция закроет сервер и завершит игру.
